CURRENTLY WORKING ON:
    * 'Remove Unit' button functionality
      * addUnitToRoster and removeUnitFromRoster should be in Roster object, not main.py

    * 'active_roster' units not clearing when "New Roster" selected
      * Consequence of separating 'updateFields' and 'updateUnitList'?

    * When user double-clicks on a unit, it takes them to the Unit page, where they can view the unit's stats and add-ons.
      * Changes made to the unit's stats on that page must be saved on-the-fly, like the Roster LineEdits do
    * Work on a way to have pre-set sizes for the columns in the Tables, both on Roster and on Unit side. 


pyuic5 RosterWindowV2.ui -o RosterWindowV2.py

        load_dialog = QFileDialog(self)
        load_dialog.setFileMode(QFileDialog.FileMode.AnyFile)
        load_dialog.setNameFilter("CrusadeTome roster files (*.ros)")
        load_dialog.setDirectory("C:\\Users\%%current_user\\Documents")
        load_dialog.setDefaultSuffix("ros")
        load_dialog.setViewMode(QFileDialog.ViewMode.Detail)

        self.active_roster.roster_name = self.ui.roster_name_line.text
        self.active_roster.roster_faction = self.ui.roster_faction_line.text
        self.active_roster.roster_owner = self.ui.roster_owner_line.text
        self.active_roster.roster_battles_total = self.ui.total_battles_line.text
        self.active_roster.roster_battles_won = self.ui.battles_won_line.text
        self.active_roster.roster_req_points = self.ui.req_points_line.text
        self.active_roster.roster_supply_limit = self.ui.supply_limit_line.text
        self.active_roster.roster_supply_used = self.ui.supply_used_line.text
        # No need to do units; by nature of how the addUnit method works,
        # The unit list is updated with every unit added 
        self.active_roster.roster_notes = self.ui.crusade_notes_text.text 


        def updateUnitList(self):
        # Change the number of rows to match the number of units
        # in the active roster's unit list.
        self.ui.unit_list_table.clearContents()
        self.ui.unit_list_table.setRowCount(len(self.active_roster.unit_list))
        # Load each unit in the unit list
        current_row = 0
        for entry in self.active_roster.unit_list:
            # TO DO: Need to change last item in each getItem to a 'QTableWidgetItem' object
            self.ui.unit_list_table.setItem(current_row, 0, QTableWidgetItem(entry.name))
            self.ui.unit_list_table.setItem(current_row, 1, QTableWidgetItem(entry.power_level))
            self.ui.unit_list_table.setItem(current_row, 2, QTableWidgetItem(entry.crusade_points))
            current_row += 1


      # whenever any of the following line edits are changed on the Roster
      # page, update the 'active_roster' object with the new values
      self.ui.roster_name_line.editingFinished.connect(self.writeToRoster)
      self.ui.roster_faction_line.editingFinished.connect(self.writeToRoster)
      self.ui.roster_owner_line.editingFinished.connect(self.writeToRoster)
      self.ui.total_battles_line.editingFinished.connect(self.writeToRoster)
      self.ui.battles_won_line.editingFinished.connect(self.writeToRoster)
      self.ui.req_points_line.editingFinished.connect(self.writeToRoster)
      self.ui.supply_limit_line.editingFinished.connect(self.writeToRoster)
      self.ui.supply_used_line.editingFinished.connect(self.writeToRoster)
      # Though clunky, the TextEdit object only has a 'textChanged' signal
      self.ui.crusade_notes_text.textChanged.connect(self.writeToRoster)